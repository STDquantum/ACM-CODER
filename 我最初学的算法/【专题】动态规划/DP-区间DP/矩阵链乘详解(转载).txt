矩阵连乘问题 详解 


创建者: gaintxiao

最后修改: 2012-10-8 16:38:01

状态: 公开 

字体 放大 / 缩小
.

题目1：

给定 n 个矩阵 {A 1,A2 ,...,An } ，相连矩阵是可乘的，但有许多不同的计算次序。
如矩阵连乘积 A1 ,A2 ,A3,A 4 , 可有下面 5 种计算次序：
(A1(A2(A3A4))) ， (A1((A2A3)A4 )) ， ((A1 A2 )(A3 A4 )) ， ((A1(A2A3))A4) ， (((A1A2)A3)A4) 。
不同计算次序需要不同的计算量，如三个矩阵相乘，维数分别为 10*100, 100*5, 5*50 。 
对于 n 个矩阵连乘，如何确定计算次序，使得需要的数乘次数最少：穷举搜索法和动态规划法。 

对于动态规划法：
用 A ij 表示从 Ai 到 Aj的乘积，即 A[i:j] 。考察计算 A[i:j] 的最优计算次序。设这个计算次序在矩阵 Ak和 Ak+1之间将矩阵链断开， i ≤ k<j ，则其相应完全加括号方式为： (AiAi+1...Ak)(Ak+1Ak+2...Aj)

计算量： A[i:k] 的计算量加上 A[k+1:j] 的计算量，再加上 A[i:k] 和 A[k+1:j] 相乘的计算量。 
特征：计算 A[i:j] 的最优次序所包含的计算矩阵子链 A[i:k] 和 A[k+1:j] 的次序也是最优的。 
矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。 

建立递归关系：

假设输入为n个矩阵(1,2,...,n)，各矩阵分别为p[0]*p[1]阶，p[1]*p[2]阶，...,p[n-1]*p[n],则输入还包括矩阵的阶数，分别为p[0],p[1],...,p[n],则第i个矩阵为p[i-1] * p[i]阶矩阵，设计算 A[i:j] ， 1 ≤ i ≤ j ≤ n ，所需要的最少数乘次数 m[i,j] ，则原问题的最优值为 m[1,n] 

当 i=j 时， A[i:j]=Ai ，因此， m[i,i]=0 ， i=1,2,…,n 

当 i<j 时， m[i,j] = m[i,k] + m[k+1, j] +pi-1pkpj （注意这里的pi-1pkpj ，m[i,k]的结果是一个pi-1pk的矩阵，m[k+1,j]是一个pkpj的矩阵）

动态规划方案代码：

1 #include<iostream>
2 using namespace std;
3 const int MAX = 100;
4 //p用来记录矩阵的阶数，
5 //m[i][j]用来记录第i个矩阵至第j个矩阵的最优解
6 //s[][]用来记录从哪里断开的才可得到该最优解
7 int p[MAX+1],m[MAX][MAX],s[MAX][MAX];
8 int n;//矩阵个数
9 
10 void matrixChain(){
11     for(int i=1;i<=n;i++)m[i][i]=0; //当 i=j 时， A[i:j]=Ai ，因此， m[i,i]=0 ， i=1,2,…,n 

//注意，在我们计算m[i,j] = m[i,k] + m[k+1, j] +pi-1pkpj 时，必须应该已经知道m[i,k]和m[k+1,j],所以我们不能直接先对i进行循环，然后在对j进行循环，这样在第一轮循环中将求m[1,1],m[1,2],m[1,3],...m[1,n]，很明显，求m[1,3]可能要用到m[1,2],m[2,3],也不可能直接进行一轮循环就求出m[1,n] --- 即最终的结果！根据m[i,j] = m[i,k] + m[k+1, j] +pi-1pkpj ，可知，要求m[i,j],必须先求得m[i,k]和m[k,j],再求m[i,j]之前先求得m[i,k]很容易做到，但是要先求得m[k,j],如何做呢？下面我们看一个例子：
m[1,3] 依赖于m[1,2],m[2,3]
m[1,4]依赖于m[1,2],m[2,4]; m[1,3],m[3,4]
m[1,5]依赖于m[1,2],m[2,5];m[1,3],m[3,5];m[1,4],m[4,5];
发现了吗？距离较大的如m[1,5]依赖于距离较小的，如m[1,2],m[2,5],所以下面我们的首层循环是对i，j间距进行循环；

13     for(int r=1;r<n;r++)//对角线循环，首先对i，j间距进行循环，i，j间距为1就不用
14         for(int i=1;i<=n-r+1;i++){//行循环
15             int j = r+i;//列的控制
16             //找m[i][j]的最小值，先初始化一下，令k=i
17             m[i][j]=m[i][i]+m[i+1][j]+p[i-1]*p[i]*p[j];
18             s[i][j]=i;
19             //k从i+1到j-1循环找m[i][j]的最小值
20             for(int k = i+1;k<j;k++){
21                 int temp=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j];
22                 if(temp<m[i][j]){
23                     m[i][j]=temp;
24                     //s[][]用来记录在子序列i-j段中，在k位置处
25                     //断开能得到最优解
26                     s[i][j]=k;
27                 }
28             }
29         }
30 }
31 
32 //根据s[][]记录的各个子段的最优解，将其输出
33 void traceback(int i,int j){
34     if(i==j)return ;
35 
36     traceback(i,s[i][j]);
37     traceback(s[i][j]+1,j);
38     cout<<"Multiply A"<<i<<","<<s[i][j]<<"and A"<<s[i][j]+1<<","<<j<<endl;
39 }
40 
41 int main(){
42     cin>>n;
43     for(int i=0;i<=n;i++)cin>>p[i];
44     //测试数据可以设为六个矩阵分别为
45     //A1[30*35],A2[35*15],A3[15*5],A4[5*10],A5[10*20],A6[20*25]
46     //则p[0-6]={30,35,15,5,10,20,25}
47     //输入：6 30 35 15 5 10 20 25
48     matrixChain();
49 
50     traceback(1,n);
51     //最终解值为m[1][n];
52     cout<<m[1][n]<<endl;
53     return 0;
54 }
